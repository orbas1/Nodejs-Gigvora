# Backend Evaluation â€“ Version 1.50

## Functionality
- **Process orchestration is tightly coupled to the web server lifecycle.** `src/server.js` boots long-running jobs (`bootstrapOpportunitySearch`, `startProfileEngagementWorker`, `startNewsAggregationWorker`) during every non-test start without readiness probes, dependency injection, or error fences. A single rejected promise terminates the Express listener, preventing blue/green or rolling deploys from ever accepting traffic.
- **API surface area is sprawling but weakly validated.** `src/routes/index.js` wires 30+ routers, yet none of the downstream controllers apply schema validation (`celebrate`, `zod`, `yup`) before touching Sequelize. Endpoints such as `searchRoutes` and `opportunitiesController.searchOpportunities` trust arbitrary filters and sort keys; malformed payloads cascade into ORM errors while missing fields silently yield empty results.
- **Search and discovery degrade sharply outside the happy path.** When Meilisearch credentials are absent, `User.searchByTerm` in `src/models/index.js` falls back to `Op.like` table scans, yielding timeouts on mid-sized datasets and ignoring typo tolerance or ranking. The Meilisearch bootstrapper in `src/services/searchIndexService.js` never verifies index health, so partial failures go unnoticed.
- **Domain modelling is inconsistent and unsustainable.** `src/models/index.js` mixes hundreds of enums with active record definitions in a single 4,000+ line module. Associates are registered indirectly, making eager-loading relationships fragile and discouraging modular ownership. Shared models are duplicated in `src/models/messagingModels.js`, risking drift between messaging and core domains.
- **Controller composition magnifies coupling.** Mega-controllers such as `src/controllers/projectsController.js` orchestrate persistence, notifications, and search updates inline, while route mounts in `src/routes/index.js` expose them under multiple overlapping prefixes (`/projects`, `/users/:userId/project-gig-management`). There is no service layer boundary or feature flag evaluation, so partially implemented features leak to production routes before backends are ready.
- **Workflow engines remain skeletal.** Payment, escrow, and compliance helpers referenced throughout `src/services` return placeholder values or TODOs. Status transitions (`GIG_ORDER_STATUSES`, `ESCROW_TRANSACTION_STATUSES`) have no guardrails, so illegal state changes, double payouts, or silent drops are easy to trigger.
- **File and media handling is incomplete.** Upload controllers rely on Multer defaults without MIME/type checks, size caps, virus scanning, or asynchronous offloading to S3/R2. Assets destined for Cloudflare or AWS block the request thread and accept unvalidated metadata, inviting abuse and breaking at scale.
- **Global middleware is incomplete.** Express is initialised in `src/app.js` without compression, body size limits, or trust proxy configuration. Large JSON payloads will exhaust memory, and deployments behind load balancers cannot respect client IPs or secure cookies.

## Usability
- **Developer ergonomics remain poor.** There is no generated OpenAPI/Swagger spec or Postman collection; engineers must infer request/response shapes from controllers and services. With 30+ routers and hundreds of handlers, onboarding requires days of spelunking across `src/controllers`.
- **Configuration lacks guardrails.** `.env.example` lists dozens of variables, yet bootstrap code never asserts their presence. Missing Stripe, Mapbox, or Meilisearch keys surface only as runtime crashes long after deployment rather than failing fast during startup.
- **Error responses are inconsistent.** The global `errorHandler` returns `{ message, details }`, but upstream layers throw raw `Error`, Sequelize `ValidationError`, or custom objects. Clients receive heterogeneous payloads and HTTP codes, forcing bespoke parsing logic in every consumer.
- **Operational tooling is absent.** Beyond `/health`, there are no readiness probes, background job dashboards, or metrics endpoints. Observability for workers, search syncs, and notification pipelines is limited to console logs, preventing SRE teams from establishing SLAs.
- **Localization and multi-tenant behaviours are ad hoc.** Middleware occasionally attaches `req.locale`/`req.tenantId`, yet controllers read directly from `req.user` or request bodies. Without shared helpers or documentation, downstream logic mixes tenant scopes and emits English-only copy, contradicting enterprise localization claims.
- **On-call debugging is guesswork.** Background workers launched from `src/server.js` log errors with `console.error`, but there is no correlation ID, request context, or structured logger. When multi-tenant customers file incidents, engineers must sift through unstructured logs across multiple services to reconstruct timelines.

## Errors & Stability
- **Error propagation is lossy.** Worker helpers (`appCache`, `bootstrapOpportunitySearch`) swallow exceptions and only log warnings; there are no retries, alerting hooks, or circuit breakers. A transient Redis or Meilisearch outage silently degrades functionality.
- **Graceful shutdown is unimplemented.** The process listens for no OS signals and never closes Sequelize pools, cache clients, or worker loops. Deployments terminate in-flight jobs mid-stream, corrupting state and leaving orphaned tasks in queues.
- **Input sanitization gaps cause crash loops.** Controllers accept nested arrays, binary blobs, and arbitrarily deep objects without shape checks. When Sequelize serializes these payloads it emits unhandled rejections that crash Node under load.
- **Testing coverage is shallow.** Jest suites exist for a few services, but there is no contract testing against live integrations, no smoke tests for background workers, and no load/performance harness. Regression detection depends entirely on manual QA.
- **Background jobs lack idempotency or deduplication.** Workers track no checkpoints; redeployments replay the same job, resending notifications or duplicating payouts. Scheduler drift is unmonitored.
- **SQLite test harness masks production issues.** `tests/setupTestEnv.js` synchronises an in-memory SQLite schema that ignores MySQL enum/index behaviour. Logic that works in tests can fail in production due to dialect mismatches.
- **Global error handling is broken.** `src/middleware/errorHandler.js` omits the Express `next` argument, so Express treats it as a standard middleware instead of an error handler. Exceptions bubble past the handler, resulting in hung requests or default HTML responses rather than structured API payloads.
- **Route files hide silent failures.** Because routers are registered via `router.use` with no per-mount logging, missing controllers or thrown promises resolve to empty 200 responses. Without instrumentation or response validation, consumers cannot distinguish success from silent no-ops.

## Integration
- **Perimeter defences are incomplete.** `app.js` defaults CORS to `'*'` while enabling credentials, triggering browser rejections and failing to enforce origin whitelists. There is no rate limiting, API key management, or gateway integration for abusive traffic.
- **External service clients are stubbed.** Agora, Stripe, Cloudflare, and Mapbox integrations appear as environment placeholders or TODO services. Without SDK initialization or feature detection, front-end teams cannot reliably toggle features per environment.
- **Notification channels lack abstraction.** Email, push, and in-app notifications instantiate bespoke services with hard-coded templates. There is no unified messaging pipeline for auditability or delivery guarantees.
- **Data export and analytics remain aspirational.** Controllers mention CSV exports and BI dashboards, yet there are no event emitters, audit logs, or warehousing connectors (Snowflake/BigQuery). Enterprise analytics integrations would require foundational redesign.
- **Multi-environment support is weak.** Configuration assumes a single production-like environment; there are no stage-specific overrides, feature flags, or sandbox credentials. Partner integrations cannot be validated safely.
- **Search infrastructure is brittle.** `searchIndexService.js` constructs index definitions inline with verbose synonyms and stop-word lists but never validates API responses or requeues failed tasks, leaving search states divergent across clusters.
- **Platform integrations are partially wired.** Files like `src/routes/workspaceTemplateRoutes.js` expose endpoints that reference non-existent services, while index aggregators mount them regardless of environment. Customers calling these routes hit 500s because feature toggles or capability checks are missing.

## Security
- **Credential handling is insecure.** Passwords are hashed with bcrypt, yet password reset tokens, 2FA codes, and magic links are stored in plaintext columns without hashing or TTL indexes. A database breach compromises all active sessions.
- **Authorization is coarse-grained.** Role checks rely on enums embedded in JWT payloads. There is no policy engine (CASL, Oso) or row-level permissions, so compromised tokens grant broad cross-tenant access.
- **Transport and perimeter protections are missing.** Beyond default Helmet headers, there is no CSP, HSTS, request body size enforcement, or TLS termination guidance. Stack traces and internal identifiers leak through error responses.
- **File uploads are unsafe.** Without MIME validation, antivirus scanning, or signed URLs, malicious payloads are accepted and served publicly, enabling malware distribution or credential harvesting.
- **Dependency security posture is weak.** There is no SAST/DAST tooling, secret scanning, or automated dependency updates. Known vulnerabilities in packages such as `jsonwebtoken` or `mysql2` could linger for months.
- **Auditability is absent.** No audit tables, change history, or immutable logs capture administrative actions. Compliance teams cannot reconstruct access or data mutations.
- **Session metadata is over-shared.** Middleware attaches full user records to `req.user` and forwards them to downstream services without redaction. Sensitive profile fields and tenant scopes bleed into logs and third-party webhook payloads, breaching data-minimization principles.

## Alignment
- **Roadmap promises vs. implementation reality diverge sharply.** The platform markets a scalable, trustworthy marketplace, yet the backend remains an MVP lacking observability, fault tolerance, and compliance guardrails. Enterprise clients would reject the current build.
- **Team workflows are misaligned.** Documentation touts cross-platform governance and analytics, but the backend exposes no APIs or admin tooling to support those promises. Product, security, and operations teams lack the controls they require.
- **Regulatory commitments go unmet.** SOC 2, GDPR, and PCI references appear in collateral, yet encryption, auditability, retention policies, and data residency controls are missing. Achieving certification demands significant rework.
- **Monolithic modelling blocks scalability.** Packing enums, models, and associations into single modules prevents domain teams from iterating independently, contradicting the stated goal of modular feature pods.
- **Incident response promises are unsupported.** Marketing copy references proactive trust and safety interventions, yet there are no abuse-report workflows, takedown SLAs, or trust tooling in backend routes. Alignment with enterprise trust commitments requires net-new systems.
