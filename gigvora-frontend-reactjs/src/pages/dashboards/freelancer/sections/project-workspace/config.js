import {
  bytesToSize,
  ensureDateTimeLocal,
  formatCurrency,
  formatDate,
  formatNumber,
  formatPercent,
  formatStatus,
  jsonToTextarea,
  listToMultiline,
  minutesToDuration,
  parseBoolean,
  parseCurrencyToCents,
  parseDateInput,
  parseFloatValue,
  parseInteger,
  parseList,
  parsePercent,
  safeJsonParse,
} from './helpers.js';

function formatCurrencyColumn(item, key, fallbackCurrency = 'USD') {
  return formatCurrency(item?.[key], item?.currency ?? fallbackCurrency);
}

export const budgetManagerConfig = {
  title: 'Budget lines',
  description: 'Plan and reconcile the delivery budget.',
  createLabel: 'Add budget line',
  emptyLabel: 'No budget lines yet. Add the first one to get started.',
  itemName: 'budget line',
  fields: [
    { name: 'category', label: 'Category', type: 'text', required: true, placeholder: 'e.g. Research sprint' },
    { name: 'description', label: 'Description', type: 'textarea', placeholder: 'What is covered by this line item?' },
    { name: 'ownerName', label: 'Budget owner', type: 'text', placeholder: 'Person accountable for this spend' },
    {
      name: 'plannedAmountCents',
      label: 'Planned amount (USD)',
      type: 'number',
      min: '0',
      step: '0.01',
      required: true,
      parse: (value) => parseCurrencyToCents(value),
      getValue: (item) => (item?.plannedAmountCents != null ? (item.plannedAmountCents / 100).toFixed(2) : ''),
    },
    {
      name: 'actualAmountCents',
      label: 'Actual amount (USD)',
      type: 'number',
      min: '0',
      step: '0.01',
      parse: (value) => parseCurrencyToCents(value),
      getValue: (item) => (item?.actualAmountCents != null ? (item.actualAmountCents / 100).toFixed(2) : ''),
    },
    {
      name: 'status',
      label: 'Status',
      type: 'select',
      options: [
        { label: 'Planned', value: 'planned' },
        { label: 'Pending approval', value: 'pending_approval' },
        { label: 'Approved', value: 'approved' },
        { label: 'In flight', value: 'in_progress' },
        { label: 'Completed', value: 'completed' },
      ],
      defaultValue: 'planned',
    },
    { name: 'currency', label: 'Currency (ISO code)', type: 'text', defaultValue: 'USD', placeholder: 'USD' },
    {
      name: 'approvalsRequired',
      label: 'Approvals required',
      type: 'number',
      min: '0',
      step: '1',
      parse: (value) => parseInteger(value),
    },
    { name: 'notes', label: 'Internal notes', type: 'textarea' },
  ],
  columns: [
    { id: 'category', label: 'Category', render: (item) => item.category },
    { id: 'planned', label: 'Planned', render: (item) => formatCurrencyColumn(item, 'plannedAmountCents') },
    { id: 'actual', label: 'Actual', render: (item) => formatCurrencyColumn(item, 'actualAmountCents') },
    { id: 'status', label: 'Status', render: (item) => formatStatus(item.status) },
    { id: 'owner', label: 'Owner', render: (item) => item.ownerName || '—' },
  ],
};

export const objectManagerConfig = {
  title: 'Delivery objects',
  description: 'Track deliverable objects tied to the project.',
  createLabel: 'Add object',
  emptyLabel: 'No objects yet. Add the first to keep things organised.',
  itemName: 'workspace object',
  fields: [
    { name: 'name', label: 'Name', type: 'text', required: true },
    {
      name: 'type',
      label: 'Type',
      type: 'select',
      options: [
        { label: 'Artifact', value: 'artifact' },
        { label: 'Deliverable', value: 'deliverable' },
        { label: 'Requirement', value: 'requirement' },
        { label: 'Checkpoint', value: 'checkpoint' },
      ],
      defaultValue: 'artifact',
    },
    {
      name: 'status',
      label: 'Status',
      type: 'select',
      options: [
        { label: 'Draft', value: 'draft' },
        { label: 'In review', value: 'in_review' },
        { label: 'Approved', value: 'approved' },
        { label: 'Published', value: 'published' },
      ],
      defaultValue: 'draft',
    },
    { name: 'ownerName', label: 'Owner', type: 'text' },
    { name: 'summary', label: 'Summary', type: 'textarea' },
    {
      name: 'dueAt',
      label: 'Due date',
      type: 'datetime-local',
      parse: (value) => parseDateInput(value),
      getValue: (item) => ensureDateTimeLocal(item?.dueAt),
    },
    {
      name: 'tags',
      label: 'Tags',
      type: 'textarea',
      placeholder: 'Enter tags separated by commas or new lines',
      parse: (value) => parseList(value),
      getValue: (item) => listToMultiline(item?.tags ?? []),
    },
  ],
  columns: [
    { id: 'name', label: 'Name', render: (item) => item.name },
    { id: 'type', label: 'Type', render: (item) => formatStatus(item.type) },
    { id: 'status', label: 'Status', render: (item) => formatStatus(item.status) },
    { id: 'owner', label: 'Owner', render: (item) => item.ownerName || '—' },
    { id: 'due', label: 'Due', render: (item) => formatDate(item.dueAt) },
  ],
};

export const timelineEventsConfig = {
  title: 'Timeline events',
  description: 'Log milestones and decision points.',
  createLabel: 'Add event',
  emptyLabel: 'No timeline events yet. Add the first milestone.',
  itemName: 'timeline event',
  fields: [
    { name: 'title', label: 'Title', type: 'text', required: true },
    { name: 'description', label: 'Description', type: 'textarea' },
    {
      name: 'eventType',
      label: 'Event type',
      type: 'select',
      options: [
        { label: 'Milestone', value: 'milestone' },
        { label: 'Decision', value: 'decision' },
        { label: 'Review', value: 'review' },
        { label: 'Launch', value: 'launch' },
        { label: 'Workshop', value: 'workshop' },
      ],
      defaultValue: 'milestone',
    },
    {
      name: 'eventDate',
      label: 'Event date',
      type: 'datetime-local',
      required: true,
      parse: (value) => parseDateInput(value, { allowNull: false }),
      getValue: (item) => ensureDateTimeLocal(item?.eventDate),
    },
    { name: 'ownerName', label: 'Owner', type: 'text' },
    {
      name: 'milestone',
      label: 'Flag as key milestone',
      type: 'checkbox',
      parse: (value) => parseBoolean(value),
      getValue: (item) => Boolean(item?.milestone),
    },
    { name: 'color', label: 'Color (hex)', type: 'color', placeholder: '#0ea5e9' },
  ],
  columns: [
    { id: 'title', label: 'Title', render: (item) => item.title },
    { id: 'date', label: 'Date', render: (item) => formatDate(item.eventDate, { withTime: true }) },
    { id: 'type', label: 'Type', render: (item) => formatStatus(item.eventType) },
    { id: 'owner', label: 'Owner', render: (item) => item.ownerName || '—' },
  ],
};

export const meetingsConfig = {
  title: 'Project meetings',
  description: 'Schedule recurring or ad-hoc meetings.',
  createLabel: 'Schedule meeting',
  emptyLabel: 'No meetings scheduled yet.',
  itemName: 'meeting',
  fields: [
    { name: 'title', label: 'Title', type: 'text', required: true },
    {
      name: 'meetingType',
      label: 'Meeting type',
      type: 'select',
      options: [
        { label: 'Sync', value: 'sync' },
        { label: 'Workshop', value: 'workshop' },
        { label: 'Review', value: 'review' },
        { label: 'Standup', value: 'standup' },
        { label: 'Retrospective', value: 'retro' },
      ],
      defaultValue: 'sync',
    },
    { name: 'agenda', label: 'Agenda', type: 'textarea' },
    { name: 'location', label: 'Location or link', type: 'text' },
    {
      name: 'startAt',
      label: 'Start time',
      type: 'datetime-local',
      required: true,
      parse: (value) => parseDateInput(value, { allowNull: false }),
      getValue: (item) => ensureDateTimeLocal(item?.startAt),
    },
    {
      name: 'endAt',
      label: 'End time',
      type: 'datetime-local',
      parse: (value) => parseDateInput(value),
      getValue: (item) => ensureDateTimeLocal(item?.endAt),
    },
    { name: 'hostName', label: 'Host', type: 'text' },
    {
      name: 'attendees',
      label: 'Attendees',
      type: 'textarea',
      placeholder: 'Separate names or emails with commas or new lines',
      parse: (value) => parseList(value),
      getValue: (item) => listToMultiline(item?.attendees ?? []),
    },
    {
      name: 'actionItems',
      label: 'Action items',
      type: 'textarea',
      placeholder: 'Track action items as a bullet list',
      parse: (value) => parseList(value),
      getValue: (item) => listToMultiline(item?.actionItems ?? []),
    },
    {
      name: 'resources',
      label: 'Resources',
      type: 'textarea',
      placeholder: 'Links or files mentioned during the meeting',
      parse: (value) => parseList(value),
      getValue: (item) => listToMultiline(item?.resources ?? []),
    },
  ],
  columns: [
    { id: 'title', label: 'Title', render: (item) => item.title },
    { id: 'start', label: 'Start', render: (item) => formatDate(item.startAt, { withTime: true }) },
    { id: 'host', label: 'Host', render: (item) => item.hostName || '—' },
    { id: 'type', label: 'Type', render: (item) => formatStatus(item.meetingType) },
  ],
};

export const calendarConfig = {
  title: 'Calendar entries',
  description: 'Capture workshops, reminders, and important dates.',
  createLabel: 'Add calendar entry',
  emptyLabel: 'No calendar entries yet.',
  itemName: 'calendar entry',
  fields: [
    { name: 'title', label: 'Title', type: 'text', required: true },
    {
      name: 'eventType',
      label: 'Event type',
      type: 'select',
      options: [
        { label: 'Event', value: 'event' },
        { label: 'Out of office', value: 'ooo' },
        { label: 'Reminder', value: 'reminder' },
        { label: 'Deadline', value: 'deadline' },
      ],
      defaultValue: 'event',
    },
    {
      name: 'startAt',
      label: 'Start time',
      type: 'datetime-local',
      required: true,
      parse: (value) => parseDateInput(value, { allowNull: false }),
      getValue: (item) => ensureDateTimeLocal(item?.startAt),
    },
    {
      name: 'endAt',
      label: 'End time',
      type: 'datetime-local',
      parse: (value) => parseDateInput(value),
      getValue: (item) => ensureDateTimeLocal(item?.endAt),
    },
    { name: 'ownerName', label: 'Owner', type: 'text' },
    {
      name: 'visibility',
      label: 'Visibility',
      type: 'select',
      options: [
        { label: 'Workspace', value: 'workspace' },
        { label: 'Client', value: 'client' },
        { label: 'Private', value: 'private' },
      ],
      defaultValue: 'workspace',
    },
  ],
  columns: [
    { id: 'title', label: 'Title', render: (item) => item.title },
    { id: 'start', label: 'Start', render: (item) => formatDate(item.startAt, { withTime: true }) },
    { id: 'owner', label: 'Owner', render: (item) => item.ownerName || '—' },
    { id: 'visibility', label: 'Visibility', render: (item) => formatStatus(item.visibility) },
  ],
};

export const rolesConfig = {
  title: 'Project roles',
  description: 'Define who does what and ensure stakeholders have the right access.',
  createLabel: 'Add role',
  emptyLabel: 'No roles documented yet. Capture delivery leads and their responsibilities.',
  itemName: 'role',
  fields: [
    { name: 'roleName', label: 'Role name', type: 'text', required: true },
    { name: 'memberName', label: 'Assigned to', type: 'text', required: true },
    { name: 'responsibilities', label: 'Responsibilities', type: 'textarea' },
    {
      name: 'permissions',
      label: 'Permissions',
      type: 'textarea',
      placeholder: 'Comma or line separated permissions',
      parse: (value) => parseList(value),
      getValue: (item) => listToMultiline(item?.permissions ?? []),
    },
    { name: 'contactEmail', label: 'Contact email', type: 'email' },
    { name: 'contactPhone', label: 'Contact phone', type: 'text' },
    { name: 'avatarUrl', label: 'Avatar URL', type: 'url' },
  ],
  columns: [
    { id: 'role', label: 'Role', render: (item) => item.roleName },
    { id: 'member', label: 'Member', render: (item) => item.memberName },
    { id: 'email', label: 'Email', render: (item) => item.contactEmail || '—' },
  ],
};

export const submissionsConfig = {
  title: 'Project submissions',
  description: 'Manage deliverables sent for review and their approval status.',
  createLabel: 'Add submission',
  emptyLabel: 'No submissions yet. Track deliverable handoffs and client approvals here.',
  itemName: 'submission',
  fields: [
    { name: 'title', label: 'Title', type: 'text', required: true },
    { name: 'description', label: 'Description', type: 'textarea' },
    {
      name: 'status',
      label: 'Status',
      type: 'select',
      options: [
        { label: 'Draft', value: 'draft' },
        { label: 'Submitted', value: 'submitted' },
        { label: 'In review', value: 'in_review' },
        { label: 'Approved', value: 'approved' },
        { label: 'Changes requested', value: 'changes_requested' },
      ],
      defaultValue: 'draft',
    },
    {
      name: 'submittedAt',
      label: 'Submitted at',
      type: 'datetime-local',
      parse: (value) => parseDateInput(value),
      getValue: (item) => ensureDateTimeLocal(item?.submittedAt),
    },
    { name: 'ownerName', label: 'Submitted by', type: 'text' },
    { name: 'reviewerName', label: 'Reviewer', type: 'text' },
    {
      name: 'decisionAt',
      label: 'Decision date',
      type: 'datetime-local',
      parse: (value) => parseDateInput(value),
      getValue: (item) => ensureDateTimeLocal(item?.decisionAt),
    },
    { name: 'decisionNotes', label: 'Decision notes', type: 'textarea' },
    {
      name: 'attachments',
      label: 'Attachments',
      type: 'textarea',
      placeholder: 'Enter URLs separated by commas or new lines',
      parse: (value) => parseList(value),
      getValue: (item) => listToMultiline(item?.attachments ?? []),
    },
  ],
  columns: [
    { id: 'title', label: 'Title', render: (item) => item.title },
    { id: 'status', label: 'Status', render: (item) => formatStatus(item.status) },
    { id: 'submitted', label: 'Submitted', render: (item) => formatDate(item.submittedAt, { withTime: true }) },
    { id: 'reviewer', label: 'Reviewer', render: (item) => item.reviewerName || '—' },
  ],
};

export const invitesConfig = {
  title: 'Invitations',
  description: 'Invite collaborators, clients, and approvers into the workspace.',
  createLabel: 'Send invite',
  emptyLabel: 'No invites sent yet. Issue an invite to collaborate on this project.',
  itemName: 'invite',
  fields: [
    { name: 'email', label: 'Email', type: 'email', required: true },
    { name: 'roleName', label: 'Role', type: 'text', required: true },
    {
      name: 'status',
      label: 'Status',
      type: 'select',
      options: [
        { label: 'Pending', value: 'pending' },
        { label: 'Accepted', value: 'accepted' },
        { label: 'Expired', value: 'expired' },
        { label: 'Revoked', value: 'revoked' },
      ],
      defaultValue: 'pending',
    },
    { name: 'invitedBy', label: 'Invited by', type: 'text' },
    {
      name: 'invitedAt',
      label: 'Invited at',
      type: 'datetime-local',
      parse: (value) => parseDateInput(value),
      getValue: (item) => ensureDateTimeLocal(item?.invitedAt),
    },
    {
      name: 'expiresAt',
      label: 'Expires at',
      type: 'datetime-local',
      parse: (value) => parseDateInput(value),
      getValue: (item) => ensureDateTimeLocal(item?.expiresAt),
    },
    {
      name: 'acceptedAt',
      label: 'Accepted at',
      type: 'datetime-local',
      parse: (value) => parseDateInput(value),
      getValue: (item) => ensureDateTimeLocal(item?.acceptedAt),
    },
    { name: 'token', label: 'Invite token', type: 'text' },
  ],
  columns: [
    { id: 'email', label: 'Email', render: (item) => item.email },
    { id: 'role', label: 'Role', render: (item) => item.roleName },
    { id: 'status', label: 'Status', render: (item) => formatStatus(item.status) },
    { id: 'invited', label: 'Invited', render: (item) => formatDate(item.invitedAt, { withTime: true }) },
  ],
};

export const hrConfig = {
  title: 'Delivery team roster',
  description: 'Track who is staffed on the project.',
  createLabel: 'Add team member',
  emptyLabel: 'No team members yet. Add the first record.',
  itemName: 'team member',
  fields: [
    { name: 'memberName', label: 'Name', type: 'text', required: true },
    { name: 'roleName', label: 'Role', type: 'text', required: true },
    {
      name: 'employmentType',
      label: 'Employment type',
      type: 'select',
      options: [
        { label: 'Contractor', value: 'contractor' },
        { label: 'Employee', value: 'employee' },
        { label: 'Vendor partner', value: 'vendor' },
      ],
      defaultValue: 'contractor',
    },
    {
      name: 'hourlyRateCents',
      label: 'Hourly rate (USD)',
      type: 'number',
      step: '0.01',
      min: '0',
      parse: (value) => parseCurrencyToCents(value),
      getValue: (item) => (item?.hourlyRateCents != null ? (item.hourlyRateCents / 100).toFixed(2) : ''),
    },
    {
      name: 'capacityHours',
      label: 'Capacity (hours/week)',
      type: 'number',
      min: '0',
      step: '1',
      parse: (value) => parseFloatValue(value),
    },
    {
      name: 'utilizationPercent',
      label: 'Utilisation %',
      type: 'number',
      min: '0',
      max: '100',
      step: '1',
      parse: (value) => parsePercent(value),
      getValue: (item) => (item?.utilizationPercent != null ? String(item.utilizationPercent) : ''),
    },
    {
      name: 'status',
      label: 'Status',
      type: 'select',
      options: [
        { label: 'Active', value: 'active' },
        { label: 'Onboarding', value: 'onboarding' },
        { label: 'Shadowing', value: 'shadowing' },
        { label: 'Completed', value: 'completed' },
      ],
      defaultValue: 'active',
    },
    { name: 'managerName', label: 'Manager', type: 'text' },
    { name: 'notes', label: 'Notes', type: 'textarea' },
  ],
  columns: [
    { id: 'name', label: 'Name', render: (item) => item.memberName },
    { id: 'role', label: 'Role', render: (item) => item.roleName },
    { id: 'rate', label: 'Rate', render: (item) => formatCurrencyColumn(item, 'hourlyRateCents') },
    { id: 'capacity', label: 'Capacity', render: (item) => formatNumber(item.capacityHours, { maximumFractionDigits: 1 }) },
    { id: 'utilization', label: 'Utilisation', render: (item) => formatPercent(item.utilizationPercent) },
  ],
};

export const timeLogConfig = {
  title: 'Hourly tracker',
  description: 'Log billable and non-billable hours.',
  createLabel: 'Log time',
  emptyLabel: 'No time entries yet.',
  itemName: 'time log',
  fields: [
    { name: 'memberName', label: 'Team member', type: 'text', required: true },
    { name: 'taskId', label: 'Task ID (optional)', type: 'number', parse: (value) => parseInteger(value) },
    {
      name: 'startedAt',
      label: 'Started at',
      type: 'datetime-local',
      required: true,
      parse: (value) => parseDateInput(value, { allowNull: false }),
      getValue: (item) => ensureDateTimeLocal(item?.startedAt),
    },
    {
      name: 'endedAt',
      label: 'Ended at',
      type: 'datetime-local',
      parse: (value) => parseDateInput(value),
      getValue: (item) => ensureDateTimeLocal(item?.endedAt),
    },
    {
      name: 'durationMinutes',
      label: 'Duration (minutes)',
      type: 'number',
      min: '0',
      step: '1',
      parse: (value) => parseInteger(value),
      getValue: (item) => (item?.durationMinutes != null ? String(item.durationMinutes) : ''),
    },
    {
      name: 'billable',
      label: 'Billable time',
      type: 'checkbox',
      parse: (value) => parseBoolean(value),
      getValue: (item) => Boolean(item?.billable ?? true),
    },
    {
      name: 'rateCents',
      label: 'Rate applied (USD)',
      type: 'number',
      min: '0',
      step: '0.01',
      parse: (value) => parseCurrencyToCents(value),
      getValue: (item) => (item?.rateCents != null ? (item.rateCents / 100).toFixed(2) : ''),
    },
    { name: 'notes', label: 'Notes', type: 'textarea' },
  ],
  columns: [
    { id: 'member', label: 'Member', render: (item) => item.memberName },
    { id: 'started', label: 'Started', render: (item) => formatDate(item.startedAt, { withTime: true }) },
    { id: 'duration', label: 'Duration', render: (item) => minutesToDuration(item.durationMinutes) },
    { id: 'billable', label: 'Billable', render: (item) => (item.billable ? 'Yes' : 'No') },
    { id: 'rate', label: 'Rate', render: (item) => formatCurrencyColumn(item, 'rateCents') },
  ],
};

export const targetsConfig = {
  title: 'Targets',
  description: 'Track quantitative KPIs for the project.',
  createLabel: 'Add target',
  emptyLabel: 'No targets yet. Add the first KPI.',
  itemName: 'target',
  fields: [
    { name: 'name', label: 'Target name', type: 'text', required: true },
    { name: 'description', label: 'Description', type: 'textarea' },
    { name: 'targetValue', label: 'Target value', type: 'number', step: '0.01', parse: (value) => parseFloatValue(value) },
    { name: 'currentValue', label: 'Current value', type: 'number', step: '0.01', parse: (value) => parseFloatValue(value) },
    { name: 'unit', label: 'Unit', type: 'text', placeholder: 'e.g. % / hours / NPS' },
    {
      name: 'dueAt',
      label: 'Due date',
      type: 'datetime-local',
      parse: (value) => parseDateInput(value),
      getValue: (item) => ensureDateTimeLocal(item?.dueAt),
    },
    {
      name: 'status',
      label: 'Status',
      type: 'select',
      options: [
        { label: 'On track', value: 'on_track' },
        { label: 'At risk', value: 'at_risk' },
        { label: 'Behind', value: 'behind' },
        { label: 'Completed', value: 'completed' },
      ],
      defaultValue: 'on_track',
    },
    { name: 'ownerName', label: 'Owner', type: 'text' },
    { name: 'trend', label: 'Trend', type: 'text', placeholder: 'e.g. improving / declining' },
  ],
  columns: [
    { id: 'name', label: 'Name', render: (item) => item.name },
    { id: 'status', label: 'Status', render: (item) => formatStatus(item.status) },
    {
      id: 'progress',
      label: 'Progress',
      render: (item) => {
        if (item.targetValue == null || item.currentValue == null) {
          return '—';
        }
        const targetValue = Number(item.targetValue);
        if (!Number.isFinite(targetValue) || targetValue === 0) {
          return formatPercent(0);
        }
        const percent = (Number(item.currentValue) / targetValue) * 100;
        return formatPercent(percent);
      },
    },
    { id: 'due', label: 'Due', render: (item) => formatDate(item.dueAt) },
    { id: 'owner', label: 'Owner', render: (item) => item.ownerName || '—' },
  ],
};

export const objectivesConfig = {
  title: 'Objectives',
  description: 'Document qualitative objectives and key results.',
  createLabel: 'Add objective',
  emptyLabel: 'No objectives yet.',
  itemName: 'objective',
  fields: [
    { name: 'title', label: 'Objective', type: 'text', required: true },
    { name: 'description', label: 'Description', type: 'textarea' },
    {
      name: 'status',
      label: 'Status',
      type: 'select',
      options: [
        { label: 'In progress', value: 'in_progress' },
        { label: 'On track', value: 'on_track' },
        { label: 'At risk', value: 'at_risk' },
        { label: 'Completed', value: 'completed' },
      ],
      defaultValue: 'in_progress',
    },
    { name: 'ownerName', label: 'Owner', type: 'text' },
    {
      name: 'dueAt',
      label: 'Due date',
      type: 'datetime-local',
      parse: (value) => parseDateInput(value),
      getValue: (item) => ensureDateTimeLocal(item?.dueAt),
    },
    {
      name: 'progressPercent',
      label: 'Progress %',
      type: 'number',
      min: '0',
      max: '100',
      step: '1',
      parse: (value) => parsePercent(value),
      getValue: (item) => (item?.progressPercent != null ? String(item.progressPercent) : ''),
    },
    {
      name: 'keyResults',
      label: 'Key results',
      type: 'textarea',
      placeholder: 'List key results separated by new lines',
      parse: (value) => parseList(value),
      getValue: (item) => listToMultiline(item?.keyResults ?? []),
    },
  ],
  columns: [
    { id: 'title', label: 'Objective', render: (item) => item.title },
    { id: 'status', label: 'Status', render: (item) => formatStatus(item.status) },
    { id: 'progress', label: 'Progress', render: (item) => formatPercent(item.progressPercent) },
    { id: 'due', label: 'Due', render: (item) => formatDate(item.dueAt) },
  ],
};

export const filesConfig = {
  title: 'File manager',
  description: 'Store deliverables, transcripts, and supporting assets with version history.',
  createLabel: 'Add file record',
  emptyLabel: 'No files added yet. Upload or reference delivery assets here.',
  itemName: 'file',
  fields: [
    { name: 'name', label: 'File name', type: 'text', required: true },
    { name: 'category', label: 'Category', type: 'text', placeholder: 'e.g. Design / Contract / Research' },
    { name: 'fileType', label: 'File type (MIME)', type: 'text', placeholder: 'application/pdf' },
    { name: 'storageProvider', label: 'Storage provider', type: 'text', defaultValue: 's3' },
    { name: 'storagePath', label: 'Storage path', type: 'text', placeholder: '/projects/123/assets/filename.pdf' },
    { name: 'version', label: 'Version', type: 'text' },
    {
      name: 'sizeBytes',
      label: 'Size (bytes)',
      type: 'number',
      min: '0',
      step: '1',
      parse: (value) => parseInteger(value),
    },
    { name: 'checksum', label: 'Checksum', type: 'text' },
    {
      name: 'tags',
      label: 'Tags',
      type: 'textarea',
      placeholder: 'Separate tags with commas or new lines',
      parse: (value) => parseList(value),
      getValue: (item) => listToMultiline(item?.tags ?? []),
    },
    {
      name: 'metadata',
      label: 'Metadata (JSON)',
      type: 'textarea',
      placeholder: '{"sensitivity":"internal"}',
      parse: (value) => safeJsonParse(value),
      getValue: (item) => jsonToTextarea(item?.metadata ?? null),
    },
  ],
  columns: [
    { id: 'name', label: 'Name', render: (item) => item.name },
    { id: 'category', label: 'Category', render: (item) => formatStatus(item.category) },
    { id: 'size', label: 'Size', render: (item) => bytesToSize(item.sizeBytes) },
    { id: 'version', label: 'Version', render: (item) => item.version || '—' },
    { id: 'updated', label: 'Updated', render: (item) => formatDate(item.updatedAt, { withTime: true }) },
  ],
};
